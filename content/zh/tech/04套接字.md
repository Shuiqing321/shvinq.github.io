+++
title= "04-Socket套接字"
date= "2021-08-20T02:20:04+08:00"
tags= ["网络编程"]
slug = "Network program04"
+++
### 创建套接字

```c
#include <sys/socket.h>
int socket(int domain, int type, int protocol); //成功返回文件描述符，失败返回-1
/*
domain: 套接字中使用的协议族(Protocol family)信息
type: 套接字数据传输类型信息
protocol: 计算机间通信中使用的协议信息
*/
```

#### 协议族分类(Protocol Family)

| 名称      | 协议族               |
| --------- | -------------------- |
| PF_INET   | IPv4互联网协议族     |
| PF_INET6  | IPv6互联网协议族     |
| PF_LOCAL  | 本地通信的UNIX协议族 |
| PF_PACKET | 底层套接字的协议族   |
| PF_IPX    | IPX Novell协议族     |

#### 套接字类型(Type)

套接字类型值得时套接字的数据传输方式。socket函数第一个参数PF_INET协议族中也存在多种数据传输方式。具有代表性的两种。

   1. 面向连接的套接字(SOCK_STREAM)

   特点：

   - 传输过程中数据不会消失
   - 按序传输数据
   - 传输的数据不存在数据边界(Boundary)

   不存在数据边界的理解：传输数据的计算机通过3次调用write函数传递了100字节数据，但是接收数据的计算机仅通过一次read函数调用就接收了这100字节数据。

   收发数据的套接字内部有缓冲(buffer)数组，通过套接字传输的数据将保存到该数组中。因此收到数据不意味着马上调用read函数，只要不超过数组容量则有可能在数据填充满缓冲后通过1次read读取，也有可能分成多次read读取。所以面向连接的套接字不存在数据边界。

套接字缓冲满了会意味着数据丢失吗？答：如果read函数读取比接收数据速度慢，缓冲可能填满。此时套接字无法再接收数据，但传输端会停止传输保证数据不会丢失。也就是面向连接的套接字会根据接收端的状态传输数据，如果传输出错还会提供重传服务。

   2. 面向消息的套接字(SOCK_DGRAM)

      特点：

      - 强调快速传输而非传输顺序
      - 传输的数据可能丢失也可能损毁
      - 传输的数据有数据边界
      - 限制每次传输的数据大小

      面向消息套接字比面向连接套接字具有更快的传输速度，但无法避免数据丢失或损毁。此外，每次传输的数据大小有限制，并存在数据边界。存在数据边界意味着接收数据的次数应和传输次数相同。

#### 协议的最终选择(Protocol)

socket函数传递前两个参数即可创建所需套接字，所以大部分情况下可以向第三个参数传递0，除非**同一协议族中存在多个数据传输方式相同的协议**。

